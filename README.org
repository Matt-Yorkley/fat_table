# FatTable

~FatTable~ is a gem that treats tables as a data type. It provides methods for
constructing tables from a variety of sources, building them row-by-row,
extracting rows, columns, and cells, and performing aggregate operations on
columns. It also provides as set of SQL-esque methods for manipulating table
objects: ~select~ for filtering by columns or for creating new columns, ~where~
for filtering by rows, ~order_by~ for sorting rows, ~distinct~ for eliminating
duplicate rows, ~group_by~ for aggregating multiple rows into single rows and
applying column aggregate methods to ungrouped columns, a collection of ~join~
methods for combining tables, and more.

Furthermore, ~FatTable~ provides methods for formatting tables and producing
output that targets various output media: text, ANSI terminals, ruby data
structures, LaTeX tables, Emacs org-mode tables, and more. The formatting
methods can specify cell formatting in a way that is uniform across all the
output methods and can also decorate the output with any number of footers,
including group footers. ~FatTable~ applies formatting directives to the extent
they makes sense for the output medium and treats other formatting directives as
no-ops.

~FatTable~ can be used to perform operations on data that are naturally best
conceived of as tables, which in my experience is quite often. It can also serve
as a foundation for providing reporting functions where flexibility about the
output medium can be quite useful. Finally ~FatTable~ can be used within Emacs
~org-mode~ files in code blocks targeting the Ruby language. Org mode tables are
presented to a ruby code block as an array of arrays, so ~FatTable~ can read
them in with its ~.from_aoa~ constructor. A ~FatTable~ table can output as an
array of arrays with its ~.to_aoa~ output function and will be rendered in an
org-mode buffer as an org-table, ready for processing by other code blocks.

* Installation

Add this line to your application's Gemfile:

#+BEGIN_SRC ruby
  gem 'fat_table'
#+END_SRC

And then execute:

#+BEGIN_SRC sh
  $ bundle
#+END_SRC

Or install it yourself as:

#+BEGIN_SRC sh
  $ gem install fat_table
#+END_SRC

* Usage

** Anatomy of a Table

*** Columns

~FatTable::Table~ objects consist of an array of ~FatTable::Column~ objects.
Each ~Column~ has a header, a type, and an array of items, all of the given type
or nil. There are only five permissible types for a ~Column~:

1. Boolean (for holding ruby ~TrueClass~ and ~FalseClass~ objects),
2. DateTime (for holding ruby ~DateTime~ or ~Date~ objects),
3. Numeric (for holding ruby ~Integer~, ~Rational~, or ~BigDecimal~ objects),
4. String (for ruby String objects), or
5. NilClass (for the undetermined column type).

When a ~Table~ is constructed from an external source, all ~Columns~ start out
having a type of ~NilClass~, that is, their type is as yet undetermined. When a
string or object of one of the four determined types is added to a ~Column~, it
fixes the type of the column and all further items added to the ~Column~ must
either be nil (indicating no value) or be capable of being coerced to the
column's type. Otherwise, ~FatTable~ raises an exception.

Items of input must be either one of the permissible ruby objects or strings. If
they are strings, ~FatTable~ attempts to parse them as one of the permissible
types as follows:

- Boolean :: the strings, 't', 'true', 'yes', or 'y', regardless of case, are
     interpreted as ~TrueClass~ and the strings, 'f', 'false', 'no', or 'n',
     regardless of case, are interpreted as ~FalseClass~, in either case
     resulting in a Boolean column. Empty strings in a column already having a
     Boolean type are converted to nil.
- DateTime :: strings that contain patterns of 'yyyy-mm-dd' or 'yyyy/mm/dd' will
     be interpreted as a ~DateTime~ or a ~Date~ (if there are no sub-day time
     components present). The number of digits in the month and day can be one
     or two, but the year component must be four digits. Any time components are
     valid if they can be properly interpreted by ~DateTime.parse~. Org mode
     timestamps, active or inactive, are valid input strings for DateTime
     columns. Empty strings in a column already having the DateTime type are
     converted to nil.
- Numeric :: all commas ',', underscores, '_', and '$' dollar signs are removed
     from the string and if the remaining string can be interpreted as a
     ~Numeric~, it will be. It is interpreted as an ~Integer~ if there are no
     decimal places in the remaining string, as a ~Rational~ if the string has
     the form '<number>:<number>' or '<number>/<number>', or as a ~BigDecimal~
     if there is a decimal point in the remaining string. Empty strings in a
     column already having the Numeric type are converted to nil.
- String :: if all else fails, ~FatTable~ applies ~#to_s~ to the input value
     and, treats it as an item of type ~String~.  Empty strings in a column
     already having the String type are kept as empty strings.
- NilClass :: until the input contains a non-blank string that can be parsed as
     one of the other types, it has this type, meaning that the type is still
     open. A column comprised completely of blank strings or nils will retain
     the ~NilClass~ type.

*** Headers

Headers for the columns are formed from the input.  If they are strings or
respond to ~#to_s~, they are converted to symbols by

- converting to a string with ~#to_s#,
- converting any run of blanks to an underscore '_',
- removing any characters that are not letters, numbers, or underscores, and
- lowercasing all remaining letters

Thus, a header of 'Date' become ~:date:, a header of 'Id Number' becomes,
~:id_number~, etc. When referring to a column in code, you must use the symbol
form of the header.

If no sensible headers can be discerned from the input, headers of the form
:col_1, :col_2, etc., are synthesized.

*** Groups

The rows of a table can be sub-divided into groups, either from markers in the
input or as a result of certain operations. There is only one level of grouping,
so ~FatTable~ has no concept of sub-groups. Groups can be shown on output with
rules or 'hlines' that underline the last row in each group, and you can
decorate the output with group footers that summarize the columns in each group.

** Constructing Tables

*** Empty Tables

You can create an empty table with ~FatTable.new~, and then add rows with the
~<<~ operator and a Hash:

#+BEGIN_SRC ruby
  tab = FatTable.new
  tab << { a: 1, b: 2, c: '<2017-01-21>', d: 'f', e: '' }
  tab << { a: 3.14, b: 2.17, c: '[2016-01-21 Thu]', d: 'Y', e: nil }
#+END_SRC

After this, the table will have column headers ~:a~, ~:b~, ~:c~, ~:d~, and ~:e~.
Column, ~:a~ and ~:b~ will have type Numeric, column ~:c~ will have type
~DateTime~, and column ~:f~ will have type ~Boolean~. Column ~:e~ will still
have an open type. Notice that dates can be wrapped in brackets as in org-mode
time stamps.

*** From CSV or Org Mode files or strings

Tables can also be read from ~.csv~ files or files containing ~org-mode~ tables.
In the case of org-mode files, ~FatTable~ skips through the file until it finds
lines that look like a table, that is they begin with any number of spaces
followed by ~'|-'.  The first row is taken as the header row in either case, and
the headers are converted to symbols as described above.

Likewise, ~FatTable~ can construct a table from a string containing a ~.csv~ or
org-mode table.

#+BEGIN_SRC ruby
    tab1 = FatTable.from_csv_file('~/data.csv')
    tab2 = FatTable.from_org_file('~/project.org')

        csv_body = <<-EOS
  Ref,Date,Code,RawShares,Shares,Price,Info
  1,2006-05-02,P,5000,5000,8.6000,2006-08-09-1-I
  2,2006-05-03,P,5000,5000,8.4200,2006-08-09-1-I
  3,2006-05-04,P,5000,5000,8.4000,2006-08-09-1-I
  4,2006-05-10,P,8600,8600,8.0200,2006-08-09-1-D
  5,2006-05-12,P,10000,10000,7.2500,2006-08-09-1-D
  6,2006-05-12,P,2000,2000,6.7400,2006-08-09-1-I
  EOS

      tab3 = FatTable.from_csv_string(csv_body)

      org_body = <<-EOS
~*~ Smith Transactions
:PROPERTIES:
:TABLE_EXPORT_FILE: smith.csv
:END:

#+TBLNAME: smith_tab
| Ref |       Date | Code |     Raw | Shares |    Price | Info    |
|-----+------------+------+---------+--------+----------+---------|
|  29 | 2013-05-02 | P    | 795,546 |  2,609 |  1.18500 | ENTITY1 |
|  30 | 2013-05-02 | P    | 118,186 |    388 | 11.85000 | ENTITY1 |
|  31 | 2013-05-02 | P    | 340,948 |  1,926 |  1.18500 | ENTITY2 |
|  32 | 2013-05-02 | P    |  50,651 |    286 | 11.85000 | ENTITY2 |
|  33 | 2013-05-20 | S    |  12,000 |     32 | 28.28040 | ENTITY3 |
|  34 | 2013-05-20 | S    |  85,000 |    226 | 28.32240 | ENTITY3 |
|  35 | 2013-05-20 | S    |  33,302 |     88 | 28.63830 | ENTITY3 |
|  36 | 2013-05-23 | S    |   8,000 |     21 | 27.10830 | ENTITY3 |
|  37 | 2013-05-23 | S    |  23,054 |     61 | 26.80150 | ENTITY3 |
|  38 | 2013-05-23 | S    |  39,906 |    106 | 25.17490 | ENTITY3 |
|  39 | 2013-05-29 | S    |  13,459 |     36 | 24.74640 | ENTITY3 |
|  40 | 2013-05-29 | S    |  15,700 |     42 | 24.77900 | ENTITY3 |
|  41 | 2013-05-29 | S    |  15,900 |     42 | 24.58020 | ENTITY3 |
|  42 | 2013-05-30 | S    |   6,679 |     18 | 25.04710 | ENTITY3 |

~*~ Another Heading
EOS

tab3 = FatTable.from_org_string(org_body)
#+END_SRC


*** From Arrays of Arrays

*** From Arrays of Hashes

*** From SQL queries

** Accessing Parts of Tables
*** Rows

*** Columns

*** Cells

** Operations on Tables

** Formatting Tables

* Development

After checking out the repo, run `bin/setup` to install dependencies. Then, run
`rake spec` to run the tests. You can also run `bin/console` for an interactive
prompt that will allow you to experiment.

To install this gem onto your local machine, run `bundle exec rake install`. To
release a new version, update the version number in `version.rb`, and then run
`bundle exec rake release`, which will create a git tag for the version, push
git commits and tags, and push the `.gem` file to
[rubygems.org](https://rubygems.org).

* Contributing

Bug reports and pull requests are welcome on GitHub at
https://github.com/ddoherty03/fat_table.
