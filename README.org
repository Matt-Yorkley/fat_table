# FatTable

~FatTable~ is a gem that treats tables as a data type. It provides methods for
constructing tables from a variety of sources, building them row-by-row,
extracting rows, columns, and cells, and performing aggregate operations on
columns. It also provides as set of SQL-esque methods for manipulating table
objects: ~select~ for filtering by columns or for creating new columns, ~where~
for filtering by rows, ~order_by~ for sorting rows, ~distinct~ for eliminating
duplicate rows, ~group_by~ for aggregating multiple rows into single rows and
applying column aggregate methods to ungrouped columns, a collection of ~join~
methods for combining tables, and more.

Furthermore, ~FatTable~ provides methods for formatting tables and producing
output that targets various output media: text, ANSI terminals, ruby data
structures, LaTeX tables, Emacs org-mode tables, and more. The formatting
methods can specify cell formatting in a way that is uniform across all the
output methods and can also decorate the output with any number of footers,
including group footers. ~FatTable~ applies formatting directives to the extent
they makes sense for the output medium and treats other formatting directives as
no-ops.

~FatTable~ can be used to perform operations on data that are naturally best
conceived of as tables, which in my experience is quite often. It can also serve
as a foundation for providing reporting functions where flexibility about the
output medium can be quite useful. Finally ~FatTable~ can be used within Emacs
~org-mode~ files in code blocks targeting the Ruby language. Org mode tables are
presented to a ruby code block as an array of arrays, so ~FatTable~ can read
them in with its ~.from_aoa~ constructor. A ~FatTable~ table can output as an
array of arrays with its ~.to_aoa~ output function and will be rendered in an
org-mode buffer as an org-table, ready for processing by other code blocks.

* Installation

Add this line to your application's Gemfile:

#+BEGIN_SRC ruby
  gem 'fat_table'
#+END_SRC

And then execute:

#+BEGIN_SRC sh
  $ bundle
#+END_SRC

Or install it yourself as:

#+BEGIN_SRC sh
  $ gem install fat_table
#+END_SRC

* Usage

** Anatomy of a Table

*** Columns

~FatTable::Table~ objects consist of an array of ~FatTable::Column~ objects.
Each ~Column~ has a header, a type, and an array of items, all of the given type
or nil. There are only five permissible types for a ~Column~:

1. Boolean (for holding ruby ~TrueClass~ and ~FalseClass~ objects),
2. DateTime (for holding ruby ~DateTime~ or ~Date~ objects),
3. Numeric (for holding ruby ~Integer~, ~Rational~, or ~BigDecimal~ objects),
4. String (for ruby String objects), or
5. NilClass (for the undetermined column type).

When a ~Table~ is constructed from an external source, all ~Columns~ start out
having a type of ~NilClass~, that is, their type is as yet undetermined. When a
string or object of one of the four determined types is added to a ~Column~, it
fixes the type of the column and all further items added to the ~Column~ must
either be nil (indicating no value) or be capable of being coerced to the
column's type. Otherwise, ~FatTable~ raises an exception.

Items of input must be either one of the permissible ruby objects or strings. If
they are strings, ~FatTable~ attempts to parse them as one of the permissible
types as follows:

- Boolean :: the strings, 't', 'true', 'yes', or 'y', regardless of case, are
     interpreted as ~TrueClass~ and the strings, 'f', 'false', 'no', or 'n',
     regardless of case, are interpreted as ~FalseClass~, in either case
     resulting in a Boolean column. Empty strings in a column already having a
     Boolean type are converted to nil.
- DateTime :: strings that contain patterns of 'yyyy-mm-dd' or 'yyyy/mm/dd' will
     be interpreted as a ~DateTime~ or a ~Date~ (if there are no sub-day time
     components present). The number of digits in the month and day can be one
     or two, but the year component must be four digits. Any time components are
     valid if they can be properly interpreted by ~DateTime.parse~. Org mode
     timestamps, active or inactive, are valid input strings for DateTime
     columns. Empty strings in a column already having the DateTime type are
     converted to nil.
- Numeric :: all commas ',', underscores, '_', and '$' dollar signs are removed
     from the string and if the remaining string can be interpreted as a
     ~Numeric~, it will be. It is interpreted as an ~Integer~ if there are no
     decimal places in the remaining string, as a ~Rational~ if the string has
     the form '<number>:<number>' or '<number>/<number>', or as a ~BigDecimal~
     if there is a decimal point in the remaining string. Empty strings in a
     column already having the Numeric type are converted to nil.
- String :: if all else fails, ~FatTable~ applies ~#to_s~ to the input value
     and, treats it as an item of type ~String~.  Empty strings in a column
     already having the String type are kept as empty strings.
- NilClass :: until the input contains a non-blank string that can be parsed as
     one of the other types, it has this type, meaning that the type is still
     open. A column comprised completely of blank strings or nils will retain
     the ~NilClass~ type.

*** Headers

Headers for the columns are formed from the input.  If they are strings or
respond to ~#to_s~, they are converted to symbols by

- converting to a string with ~#to_s#,
- converting any run of blanks to an underscore '_',
- removing any characters that are not letters, numbers, or underscores, and
- lowercasing all remaining letters

Thus, a header of 'Date' become ~:date:, a header of 'Id Number' becomes,
~:id_number~, etc. When referring to a column in code, you must use the symbol
form of the header.

If no sensible headers can be discerned from the input, headers of the form
:col_1, :col_2, etc., are synthesized.

*** Groups

The rows of a table can be sub-divided into groups, either from markers in the
input or as a result of certain operations. There is only one level of grouping,
so ~FatTable~ has no concept of sub-groups. Groups can be shown on output with
rules or 'hlines' that underline the last row in each group, and you can
decorate the output with group footers that summarize the columns in each group.

** Constructing Tables

*** Empty Tables

You can create an empty table with ~FatTable.new~, and then add rows with the
~<<~ operator and a Hash:

#+BEGIN_SRC ruby
  tab = FatTable.new
  tab << { a: 1, b: 2, c: '<2017-01-21>', d: 'f', e: '' }
  tab << { a: 3.14, b: 2.17, c: '[2016-01-21 Thu]', d: 'Y', e: nil }
#+END_SRC

After this, the table will have column headers ~:a~, ~:b~, ~:c~, ~:d~, and ~:e~.
Column, ~:a~ and ~:b~ will have type Numeric, column ~:c~ will have type
~DateTime~, and column ~:f~ will have type ~Boolean~. Column ~:e~ will still
have an open type. Notice that dates can be wrapped in brackets as in org-mode
time stamps.

*** From CSV or Org Mode files or strings

Tables can also be read from ~.csv~ files or files containing ~org-mode~ tables.
In the case of org-mode files, ~FatTable~ skips through the file until it finds
a line that look like a table, that is it begins with any number of spaces
followed by ~'|-'. The first row is taken as the header row in either case, and
the headers are converted to symbols as described above.  Only the first table
in the file is read.

Likewise, ~FatTable~ can construct a table from a string containing a ~.csv~ or
org-mode table.

#+BEGIN_SRC ruby
      tab1 = FatTable.from_csv_file('~/data.csv')
      tab2 = FatTable.from_org_file('~/project.org')

      csv_body = <<-EOS
    Ref,Date,Code,RawShares,Shares,Price,Info
    1,2006-05-02,P,5000,5000,8.6000,2006-08-09-1-I
    2,2006-05-03,P,5000,5000,8.4200,2006-08-09-1-I
    3,2006-05-04,P,5000,5000,8.4000,2006-08-09-1-I
    4,2006-05-10,P,8600,8600,8.0200,2006-08-09-1-D
    5,2006-05-12,P,10000,10000,7.2500,2006-08-09-1-D
    6,2006-05-12,P,2000,2000,6.7400,2006-08-09-1-I
    EOS

      tab3 = FatTable.from_csv_string(csv_body)

      org_body = <<-EOS
  .* Smith Transactions
  :PROPERTIES:
  :TABLE_EXPORT_FILE: smith.csv
  :END:

  #+TBLNAME: smith_tab
  | Ref |       Date | Code |     Raw | Shares |    Price | Info    |
  |-----+------------+------+---------+--------+----------+---------|
  |  29 | 2013-05-02 | P    | 795,546 |  2,609 |  1.18500 | ENTITY1 |
  |  30 | 2013-05-02 | P    | 118,186 |    388 | 11.85000 | ENTITY1 |
  |  31 | 2013-05-02 | P    | 340,948 |  1,926 |  1.18500 | ENTITY2 |
  |  32 | 2013-05-02 | P    |  50,651 |    286 | 11.85000 | ENTITY2 |
  |  33 | 2013-05-20 | S    |  12,000 |     32 | 28.28040 | ENTITY3 |
  |  34 | 2013-05-20 | S    |  85,000 |    226 | 28.32240 | ENTITY3 |
  |  35 | 2013-05-20 | S    |  33,302 |     88 | 28.63830 | ENTITY3 |
  |  36 | 2013-05-23 | S    |   8,000 |     21 | 27.10830 | ENTITY3 |
  |  37 | 2013-05-23 | S    |  23,054 |     61 | 26.80150 | ENTITY3 |
  |  38 | 2013-05-23 | S    |  39,906 |    106 | 25.17490 | ENTITY3 |
  |  39 | 2013-05-29 | S    |  13,459 |     36 | 24.74640 | ENTITY3 |
  |  40 | 2013-05-29 | S    |  15,700 |     42 | 24.77900 | ENTITY3 |
  |  41 | 2013-05-29 | S    |  15,900 |     42 | 24.58020 | ENTITY3 |
  |  42 | 2013-05-30 | S    |   6,679 |     18 | 25.04710 | ENTITY3 |

  .* Another Heading
  EOS

      tab4 = FatTable.from_org_string(org_body)
#+END_SRC


*** From Arrays of Arrays

Rather than read the table from text, you can also initialize a table directly
from ruby data structures.  First, you can build a table from an array of
arrays:

#+BEGIN_SRC ruby
  aoa =
    [['Ref', 'Date', 'Code', 'Raw', 'Shares', 'Price', 'Info', 'Bool'],
     [1, '2013-05-02', 'P', 795_546.20, 795_546.2, 1.1850, 'ENTITY1', 'T'],
     [2, '2013-05-02', 'P', 118_186.40, 118_186.4, 11.8500, 'ENTITY1', 'T'],
     [7, '2013-05-20', 'S', 12_000.00, 5046.00, 28.2804, 'ENTITY3', 'F'],
     [8, '2013-05-20', 'S', 85_000.00, 35_742.50, 28.3224, 'ENTITY3', 'T'],
     [9, '2013-05-20', 'S', 33_302.00, 14_003.49, 28.6383, 'ENTITY3', 'T'],
     [10, '2013-05-23', 'S', 8000.00, 3364.00, 27.1083, 'ENTITY3', 'T'],
     [11, '2013-05-23', 'S', 23_054.00, 9694.21, 26.8015, 'ENTITY3', 'F'],
     [12, '2013-05-23', 'S', 39_906.00, 16_780.47, 25.1749, 'ENTITY3', 'T'],
     [13, '2013-05-29', 'S', 13_459.00, 5659.51, 24.7464, 'ENTITY3', 'T'],
     [14, '2013-05-29', 'S', 15_700.00, 6601.85, 24.7790, 'ENTITY3', 'F'],
     [15, '2013-05-29', 'S', 15_900.00, 6685.95, 24.5802, 'ENTITY3', 'T'],
     [16, '2013-05-30', 'S', 6_679.00, 2808.52, 25.0471, 'ENTITY3', 'T']]
tab = FatTable.from_aoa(aoa)
#+END_SRC

This method of building a table is particularly useful in dealing with Emacs
org-mode code blocks.  Tables in org-mode are passed to code blocks as arrays of
arrays.  Likewise, a result of a code block in the form of an array of arrays is
displayed as an org-mode table:

#+BEGIN_EXAMPLE
#+NAME: trades1
| Ref  |       Date | Code |  Price | G10 | QP10 | Shares |    LP |     QP |   IPLP |   IPQP |
|------+------------+------+--------+-----+------+--------+-------+--------+--------+--------|
| T001 | 2016-11-01 | P    | 7.7000 | T   | F    |    100 |    14 |     86 | 0.2453 | 0.1924 |
| T002 | 2016-11-01 | P    | 7.7500 | T   | F    |    200 |    28 |    172 | 0.2453 | 0.1924 |
| T003 | 2016-11-01 | P    | 7.5000 | F   | T    |    800 |   112 |    688 | 0.2453 | 0.1924 |
| T004 | 2016-11-01 | S    | 7.5500 | T   | F    |   6811 |   966 |   5845 | 0.2453 | 0.1924 |
| T005 | 2016-11-01 | S    | 7.5000 | F   | F    |   4000 |   572 |   3428 | 0.2453 | 0.1924 |
| T006 | 2016-11-01 | S    | 7.6000 | F   | T    |   1000 |   143 |    857 | 0.2453 | 0.1924 |
| T007 | 2016-11-01 | S    | 7.6500 | T   | F    |    200 |    28 |    172 | 0.2453 | 0.1924 |
| T008 | 2016-11-01 | P    | 7.6500 | F   | F    |   2771 |   393 |   2378 | 0.2453 | 0.1924 |
| T009 | 2016-11-01 | P    | 7.6000 | F   | F    |   9550 |  1363 |   8187 | 0.2453 | 0.1924 |
| T010 | 2016-11-01 | P    | 7.5500 | F   | T    |   3175 |   451 |   2724 | 0.2453 | 0.1924 |
| T011 | 2016-11-02 | P    | 7.4250 | T   | F    |    100 |    14 |     86 | 0.2453 | 0.1924 |
| T012 | 2016-11-02 | P    | 7.5500 | F   | F    |   4700 |   677 |   4023 | 0.2453 | 0.1924 |
| T013 | 2016-11-02 | P    | 7.3500 | T   | T    |  53100 |  7656 |  45444 | 0.2453 | 0.1924 |
| T014 | 2016-11-02 | P    | 7.4500 | F   | T    |   5847 |   835 |   5012 | 0.2453 | 0.1924 |
| T015 | 2016-11-02 | P    | 7.7500 | F   | F    |    500 |    72 |    428 | 0.2453 | 0.1924 |
| T016 | 2016-11-02 | P    | 8.2500 | T   | T    |    100 |    14 |     86 | 0.2453 | 0.1924 |

#+HEADER: :colnames no
:#+BEGIN_SRC ruby :var tab=trades1
  require 'fat_table'
  tab = FatTable.from_aoa(tab).where('shares > 500')
  FatTable.to_aoa(tab)
:#+END_SRC

#+RESULTS:
| Ref  |       Date | Code | Price | G10 | QP10 | Shares |   Lp |    Qp |   Iplp |   Ipqp |
|------+------------+------+-------+-----+------+--------+------+-------+--------+--------|
| T003 | 2016-11-01 | P    |   7.5 | F   | T    |    800 |  112 |   688 | 0.2453 | 0.1924 |
| T004 | 2016-11-01 | S    |  7.55 | T   | F    |   6811 |  966 |  5845 | 0.2453 | 0.1924 |
| T005 | 2016-11-01 | S    |   7.5 | F   | F    |   4000 |  572 |  3428 | 0.2453 | 0.1924 |
| T006 | 2016-11-01 | S    |   7.6 | F   | T    |   1000 |  143 |   857 | 0.2453 | 0.1924 |
| T008 | 2016-11-01 | P    |  7.65 | F   | F    |   2771 |  393 |  2378 | 0.2453 | 0.1924 |
| T009 | 2016-11-01 | P    |   7.6 | F   | F    |   9550 | 1363 |  8187 | 0.2453 | 0.1924 |
| T010 | 2016-11-01 | P    |  7.55 | F   | T    |   3175 |  451 |  2724 | 0.2453 | 0.1924 |
| T012 | 2016-11-02 | P    |  7.55 | F   | F    |   4700 |  677 |  4023 | 0.2453 | 0.1924 |
| T013 | 2016-11-02 | P    |  7.35 | T   | T    |  53100 | 7656 | 45444 | 0.2453 | 0.1924 |
| T014 | 2016-11-02 | P    |  7.45 | F   | T    |   5847 |  835 |  5012 | 0.2453 | 0.1924 |
#+END_EXAMPLE

This example illustrates several things:

1. The named org-mode table, 'trades1', can be passed into a ruby code block
   using the '~:var tab=trades1~' header argument to the code block; that makes
   the variable ~tab~ available to the code block as an array of arrays, which
   ~FatTable~ then uses to initialize the table.
2. The code block requires that you set '~:colnames no~ in the header arguments.
   This suppresses org-mode's own processing of the header line so that
   ~FatTable~ can see the headers.  Failure to do this will cause an error.
3. The table is subjected to some processing, in this case selecting those rows
   where the number of shares is greater than 500.  More on that later.
4. ~FatTable~ passes back to org-mode an array of arrays using the
   ~FatTable.to_aoa~ function. As we'll see below, this method can also take a
   block to which formatting instructions and footers can be attached.

*** From Arrays of Hashes

A second ruby structure that can be used to initialize a ~FatTable~ table is an
array of ruby Hashes.  Each hash represents a row of the table, and the headers
of the table are take from the keys of the hashes.  Accordingly, all the hashes
should have the same keys.

#+BEGIN_SRC ruby
aoh = [
  { ref: 'T001', date: '2016-11-01', code: 'P', price: '7.7000',  shares: 100 },
  { ref: 'T002', date: '2016-11-01', code: 'P', price: 7.7500,  shares: 200 },
  { ref: 'T003', date: '2016-11-01', code: 'P', price: 7.5000,  shares: 800 },
  { ref: 'T004', date: '2016-11-01', code: 'S', price: 7.5500,  shares: 6811 },
  { ref: 'T005', date: Date.today, code: 'S', price: 7.5000,  shares: 4000 },
  { ref: 'T006', date: '2016-11-01', code: 'S', price: 7.6000,  shares: 1000 },
  { ref: 'T007', date: '2016-11-01', code: 'S', price: 7.6500,  shares: 200 },
  { ref: 'T008', date: '2016-11-01', code: 'P', price: 7.6500,  shares: 2771 },
  { ref: 'T009', date: '2016-11-01', code: 'P', price: 7.6000,  shares: 9550 },
  { ref: 'T010', date: '2016-11-01', code: 'P', price: 7.5500,  shares: 3175 },
  { ref: 'T011', date: '2016-11-02', code: 'P', price: 7.4250,  shares: 100 },
  { ref: 'T012', date: '2016-11-02', code: 'P', price: 7.5500,  shares: 4700 },
  { ref: 'T013', date: '2016-11-02', code: 'P', price: 7.3500,  shares: 53100 },
  { ref: 'T014', date: '2016-11-02', code: 'P', price: 7.4500,  shares: 5847 },
  { ref: 'T015', date: '2016-11-02', code: 'P', price: 7.7500,  shares: 500 },
  { ref: 'T016', date: '2016-11-02', code: 'P', price: 8.2500,  shares: 100 }
]
tab = FatTable.from_aoh(aoh)
#+END_SRC

Notice that the values can either be ruby objects, such as ~Date.today~, or
strings that can parsed into one of the permissible column types.

*** From SQL queries

Another way to initialize a ~FatTable~ table is with the results of a SQL query.
~FatTable~ uses the ~dbi~ gem to query databases.  In this case, you must first
set the database parameters to be used for the queries.

#+BEGIN_SRC ruby
  require 'fat_table'
  FatTable.set_db(driver: 'Pg',
                  database: 'XXX_development',
                  user: 'dtd',
                  password: 'slflpowert',
                  host: 'localhost',
                  socket: '/tmp/.s.PGSQL.5432')
  tab = FatTable.from_sql('select * from trades;')
#+END_SRC

Some of the parameters to the ~.set_db~ function have defaults. The driver
defaults to 'Pg' for postgresql and the socket defaults to '/tmp/.s.PGSQL.5432'
if the host is 'localhost', which it is by default. If the host is not
'localhost', the dsn uses a port rather than a socket and defaults to port
'5432'. While user and password default to nil, the database parameter is
required.

The ~.set_db~ function need only be set once, and the database handle it creates
will be used for all subsequent ~.from_sql~ calls.

** Accessing Parts of Tables
*** Rows

A ~FatTable~ table is an Enumerable, yielding each row of the table as a Hash
keyed on the header symbols.  The method ~Table#rows~ returns an Array of the rows as
Hashes as well.

You can also use indexing to access a row of the table by number. Using an
integer index returns a Hash of the given row. Thus, ~tab[20]~ returns the 21st
data row of the table, while ~tab[0]~ returns the first row and tab[-1] returns
the last row.

*** Columns

If the index provided to ~[]~ is a string or a symbol, it returns an Array of
the items of the column with that header. Thus, ~tab[:ref]~ returns an Array of
all the items of the table's ~:ref~ column.

*** Cells

The two forms of indexing can be combined to access individual cells of the
table:
#+BEGIN_SRC ruby
  tab[13]         # => Hash of the 14th row
  tab[:date]      # => Array of all Dates in the :date column
  tab[13][:date]  # => The Date in the 14th row
  tab[:date][13]  # => The Date in the 14th row; indexes can be in either order.
#+END_SRC

*** Other table attributes

#+BEGIN_SRC ruby
  tab.headers       # => an Array of the headers in symbol form
  tab.types         # => an Array of the column types
  tab.size          # => the number of rows in the table
  tab.empty?        # => is the table empty?
  tab.column?(head) # => does the table have a column with the given header?
  tab.groups        # => return an Array of an Array of row Hashes.
#+END_SRC

** Operations on Tables

Once you have one or more tables, you will likely want to perform operations on
them. The operations provided by ~FatTable~ are the subject of this section.
Before getting into the operations, though, there are a couple of issues that
cut across all or many of the operations.

First, tables are by and large immutable objects. Each operation creates a new
table without affecting the input tables. Where this is not the case, it will be
noted below.

Second, because each operation results in a ~FatTable::Table~ object, the
operations are chainable.

Third, ~FatTable::Table~ objects can have "groups" of rows within the table.
These can be decorated with hlines and group footers on output. Some of these
operations result in marking group boundaries in the result table, others remove
group boundaries that may have existed in the input table. Operations that
either create or remove groups will also be noted below.

Finally, the operations are for the most part patterned on SQL table operations,
but when expressions play a role, you write them using ruby syntax rather than
SQL, or worse, a totally new made-up language.

*** Example Input Table

For illustration purposes, we'll assume that the following table is, read into a
ruby variable called 'trades' using one of the input methods above.  We have
given the table groups, marked by the hlines below, to illustrate the affect of
operations on groups if applicable.

#+BEGIN_EXAMPLE
#+NAME: trades
| Ref  |       Date | Code |  Price | G10 | QP10 | Shares |    LP |     QP |   IPLP |   IPQP |
|------+------------+------+--------+-----+------+--------+-------+--------+--------+--------|
| T001 | 2016-11-01 | P    | 7.7000 | T   | F    |    100 |    14 |     86 | 0.2453 | 0.1924 |
| T002 | 2016-11-01 | P    | 7.7500 | T   | F    |    200 |    28 |    172 | 0.2453 | 0.1924 |
| T003 | 2016-11-01 | P    | 7.5000 | F   | T    |    800 |   112 |    688 | 0.2453 | 0.1924 |
|------+------------+------+--------+-----+------+--------+-------+--------+--------+--------|
| T004 | 2016-11-01 | S    | 7.5500 | T   | F    |   6811 |   966 |   5845 | 0.2453 | 0.1924 |
| T005 | 2016-11-01 | S    | 7.5000 | F   | F    |   4000 |   572 |   3428 | 0.2453 | 0.1924 |
| T006 | 2016-11-01 | S    | 7.6000 | F   | T    |   1000 |   143 |    857 | 0.2453 | 0.1924 |
| T007 | 2016-11-01 | S    | 7.6500 | T   | F    |    200 |    28 |    172 | 0.2453 | 0.1924 |
| T008 | 2016-11-01 | P    | 7.6500 | F   | F    |   2771 |   393 |   2378 | 0.2453 | 0.1924 |
| T009 | 2016-11-01 | P    | 7.6000 | F   | F    |   9550 |  1363 |   8187 | 0.2453 | 0.1924 |
|------+------------+------+--------+-----+------+--------+-------+--------+--------+--------|
| T010 | 2016-11-01 | P    | 7.5500 | F   | T    |   3175 |   451 |   2724 | 0.2453 | 0.1924 |
| T011 | 2016-11-02 | P    | 7.4250 | T   | F    |    100 |    14 |     86 | 0.2453 | 0.1924 |
| T012 | 2016-11-02 | P    | 7.5500 | F   | F    |   4700 |   677 |   4023 | 0.2453 | 0.1924 |
| T013 | 2016-11-02 | P    | 7.3500 | T   | T    |  53100 |  7656 |  45444 | 0.2453 | 0.1924 |
|------+------------+------+--------+-----+------+--------+-------+--------+--------+--------|
| T014 | 2016-11-02 | P    | 7.4500 | F   | T    |   5847 |   835 |   5012 | 0.2453 | 0.1924 |
| T015 | 2016-11-02 | P    | 7.7500 | F   | F    |    500 |    72 |    428 | 0.2453 | 0.1924 |
| T016 | 2016-11-02 | P    | 8.2500 | T   | T    |    100 |    14 |     86 | 0.2453 | 0.1924 |
#+END_EXAMPLE

*** Select

With the ~select~ method, you can select which existing columns should appear in
the output table and create new columns in the output table that are a function
of existing and new columns.

Here we select three existing columns by simply passing header symbols in the
order we want them to appear in the output. Thus, one use of =select= is to
filter and permute the order of existing columns. The =select= method preserves
any group boundaries present in the input table.
#+BEGIN_SRC ruby
  trades.select(:price, :ref, :shares)
#+END_SRC

#+BEGIN_EXAMPLE
| Price | Ref  | Shares |
|-------+------+--------|
|   7.7 | T001 |    100 |
|  7.75 | T002 |    200 |
|   7.5 | T003 |    800 |
|-------+------+--------|
|  7.55 | T004 |   6811 |
|   7.5 | T005 |   4000 |
|   7.6 | T006 |   1000 |
|  7.65 | T007 |    200 |
|  7.65 | T008 |   2771 |
|   7.6 | T009 |   9550 |
|-------+------+--------|
|  7.55 | T010 |   3175 |
| 7.425 | T011 |    100 |
|  7.55 | T012 |   4700 |
|  7.35 | T013 |  53100 |
|-------+------+--------|
|  7.45 | T014 |   5847 |
|  7.75 | T015 |    500 |
|  8.25 | T016 |    100 |
#+END_EXAMPLE

*** Where

*** Order_by

*** Group_by

*** Join

*** Union, Intersect, and Except

*** Uniq (aka Distinct)

*** Nogroups

** Formatting Tables

* Development

After checking out the repo, run `bin/setup` to install dependencies. Then, run
`rake spec` to run the tests. You can also run `bin/console` for an interactive
prompt that will allow you to experiment.

To install this gem onto your local machine, run `bundle exec rake install`. To
release a new version, update the version number in `version.rb`, and then run
`bundle exec rake release`, which will create a git tag for the version, push
git commits and tags, and push the `.gem` file to
[rubygems.org](https://rubygems.org).

* Contributing

Bug reports and pull requests are welcome on GitHub at
https://github.com/ddoherty03/fat_table.
